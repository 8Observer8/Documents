Обзор паттернов проектирования

Привет!

Предлагаю в этой теме на примерах сделать обзор по паттернам проектирования. Наверняка вы можете подробно описать те паттерны, которые используете на практике.

Предлагаю такой формат:
- название паттерна
- описание своими словами
- демонстрационный пример
- ссылка на книгу или ресурс с более подробным описанием

Мне всё равно никуда уже не деться от изучения всех паттернов :) Думаю, стоит потратить время, чтобы изучить досконально все паттрены. Конечно хорошо бы учиться применять это на практике. Здесь вижу единственный вариант: заучивать примеры из книг и развивать их, фантазиваровать. А паттернов не так уж и много :)

[quote author=8Observer8 link=topic=26920.msg194512#msg194512 date=1398485207]
Широко ли используется сейчас идиома невиртуального интерфейса (NVI) в индустрии разработки ПО для реализации паттерна "Шаблонный метод"?
[/quote]

Ответ на этот вопрос здесь: http://www.e-reading.ws/chapter.php/1002058/88/Mayers_-_Effektivnoe_ispolzovanie_CPP.html

Вот он ответ:
[quote]
Идиома NVI – это интересная альтернатива открытым виртуальным функциям, но с точки зрения проектирования она дает не слишком много. В конце концов, мы по-прежнему используем виртуальные функции для вычисления жизненной силы каждого персонажа. С точки зрения проектирования гораздо более сильным было бы утверждение о том, что вычисление жизненной силы персонажа не зависит от типа персонажа, что такие вычисления вообще не являются свойством персонажа как такового. Например, мы можем потребовать, чтобы конструктору каждого персонажа передавался указатель на функцию, которая вызывалась бы для вычисления его жизненной силы:
[/quote]

Ещё, судя из правила выше, место реализации паттерна "Шаблонный метод" (через идиому невиртуального интерфейса) предлагается другой паттерн - "Стратегия". Из-за того, что в данной задаче более логично указывать функцию вычисления жизненной силы при создании объекта, то есть передавать указатель на функцию в конструкторе и\или же менять функцию вычисления жизненной силы с помощью void setHealthCalculator( HealthCalcFunc hcf ). Это повышает гибкость. Теперь функция вычисления жизненной силы не зависит от типа объекта и её можно менять во время исполнения.

Как я понял - открытые виртуальные функции это плохо если мы хотим проводить какие-то инициализирующие операции до вызова переопределяемого метода и проводить какие-то завершающие операции после вызова.

Как мне кажется, когда говорят, что мы применяем "Шаблонный метод", то имеется ввиду, что мы применяем идиому NVI. Или NVI - это уже только для C++?

Здесь приведена реализация паттерна «Стратегия» посредством указателей на функции: http://www.e-reading.ws/chapter.php/1002058/88/Mayers_-_Effektivnoe_ispolzovanie_CPP.html

Повысилась гибкость (это цитаты по ссылке выше):
- Разные экземпляры персонажей одного и того же типа могут иметь разные функции вычисления жизненной силы. 
- Функция вычисления жизненной силы для одного и того же персонажа может изменяться во время исполнения. Например, класс GameCharacter мог бы предложить функцию-член setHealthCalculator, которая позволяет заменить текущую функцию вычисления жизненной силы.

На этом примере более или менее понятно почему мы перешли от паттерна "Шаблонный метод" к паттерну "Стратегия". Надеюсь, что это можно будет применить где-то ещё :)

Я сделал пример реализации более наглядным. В файле main.cpp сначала создаю персонажа класса Player и монстра класса EvilBadGay. У них функция вычисления жизненной силы - по умолчанию. Потом меняю им функции с помощью метода базового класса: void setHealthCalculator( HealthCalcFunc hcf )

main.cpp
[code=cpp]
#include <iostream>
#include "Player.h"
#include "EvilBadGay.h"
#include "functionsForHealthCalc.h"

int main() {
    GameStuff::Player player(std::string("David"));
    GameStuff::EvilBadGay monster(std::string("Black"));

    std::cout << "Name: " << player.name( ) << std::endl;
    std::cout << "Health Value: " << player.healthValue( ) << std::endl;
    std::cout << std::endl;

    std::cout << "Name: " << monster.name( ) << std::endl;
    std::cout << "Health Value: " << monster.healthValue( ) << std::endl;
    std::cout << std::endl;

    // Change health functions
    player.setHealthCalculator(GameStuff::loseHealthSlowly);
    monster.setHealthCalculator(GameStuff::loseHealthQuickly);

    std::cout << "After changing health functions:" << std::endl;
    std::cout << std::endl;

    std::cout << "Name: " << player.name( ) << std::endl;
    std::cout << "Health Value: " << player.healthValue( ) << std::endl;
    std::cout << std::endl;

    std::cout << "Name: " << monster.name( ) << std::endl;
    std::cout << "Health Value: " << monster.healthValue( ) << std::endl;

    return 0;
}
[/code]

Output:
[quote]
Name: David
Health Value: 1

Name: Black
Health Value: 1

After changing health functions:

Name: David
Health Value: 2

Name: Black
Health Value: 3[/quote]

Весь код примера: https://github.com/8Observer8/pattern_StrategyByFuncPointers


//!!!
Помогите, пожалуйста, разобрать и усвоить все паттерны из предыдущего моего сообщения. Я буду переписывать примеры, развивать их, а вы контролируйте меня. По ходу будет возникать много вопросов :)

На данный момент, я усвоил два паттерна: паттерн "Шаблонный метод" и паттерн "Стратегия".

Понял, что для реализации функции вычисления жизненной силы паттерн "Шаблонный метод" не подходит. Во всяком случае, в этом примере у нас нет "предварительный действий" с инициализацией и "завершающих действий" с освобождением ресурсов.

Для реализации функции вычисления жизненной силы лучше всего подойдёт паттерн "Стратегия". С его помощью мы можем менять функцию вычисления жизненной силы во время выполнения программы с помощью этого метода:
[code=cpp]
void setHealthCalculator( HealthCalcFunc hcf ) {
    healthFunc = hcf;
}
[/code]

Вот здесь описана более универсальная реализация паттерна "Стратегия" с помощью класса function (С++11) http://www.e-reading.ws/chapter.php/1002058/89/Mayers_-_Effektivnoe_ispolzovanie_CPP.html

Теперь мы можем задавать алгоритм вычисления жизненной силы не только с помощью передачи функции, но и с помощью передачи функциональных объектов и методов других классов. Главное чтобы сигнатура вызываемой сущности была совместимой с заданной, то есть чтобы параметр можно было неявно преобразовать в const GameCharacter&, а тип возвращаемого значения неявно конвертировать в int. Причём реализация паттерна "Стратегия" с помощью указателя на функцию и реализация паттерна "Стратегия" с помощью класса function отличаются только одной строкой в классе GameCharacter. В первом случае:
[code=cpp]
typedef int (*HealthCalcFunc)(const GameCharacter&);
[/code]

Во втором случае:
[code=cpp]
typedef std::function<int (const GameCharacter&)> HealthCalcFunc;
[/code]

Вот такие сущности мы можем теперь применять для вычисления жизненной силы:
[code=cpp]
#ifndef FUNCTIONS_FOR_HEALTHCALC_H
#define FUNCTIONS_FOR_HEALTHCALC_H

namespace GameStuff {

    class GameCharacter; // опережающее объявление

    /**
     * Функции вычисления жизненной силы; она возвращает не int
     */
    short calcHealth( const GameCharacter& gc );

    /**
     * Класс функциональных объектов, вычисляющих жизненную силу
     */
    struct HealthCalculator {

        int operator()(const GameCharacter&) const {
            return 5;
        }
    };

    /**
     * Функция алгоритма по умолчанию для вычисления жизненной силы персонажа
     */
    int defaultHealthCalc( const GameCharacter& gc );

    /**
     * Функции вычисления жизненной силы с другим поведением
     */
    int loseHealthQuickly( const GameCharacter& gc );

    /**
     * Функции вычисления жизненной силы с другим поведением
     */
    int loseHealthSlowly( const GameCharacter& gc );
}

#endif // FUNCTIONS_FOR_HEALTHCALC_H
[/code]

Исходный код реализации паттерна "Стратегия" с помощью класса function: https://github.com/8Observer8/pattern_StrategyByFunctionClass