Рисование фигур

Почему не срабатывает?
    glEnable(GL_CULL_FACE); // устанавливаем режим, когда строятся только внешние поверхности

У куба обход индексов должен быть по часовой стрелке (по треугольнику) Надо сделать, чтобы оси выглядывали

Функция draw() возвращает массив вершин для рисования

2 * Pi * 0/8 = 2 * Pi * 0
2 * Pi * 1/8 = 2 * Pi * 0.125
2 * Pi * 2/8 = 2 * Pi * 0.25
2 * Pi * 3/8 = 2 * Pi * 0.375
2 * Pi * 4/8 = 2 * Pi * 0.5
2 * Pi * 5/8 = 2 * Pi * 0.625
2 * Pi * 6/8 = 2 * Pi * 0.75
2 * Pi * 7/8 = 2 * Pi * 0.875

cos(2 * Pi * 0) = 1
sin(2 * Pi * 0) = 0

cos(2 * Pi * 0.125) = +x
sin(2 * Pi * 0.125) = +x

cos(2 * Pi * 0.25) = 0
sin(2 * Pi * 0.25) = 1

cos(2 * Pi * 0.375) = -x
sin(2 * Pi * 0.375) = +x

cos(2 * Pi * 0.5) = -1
sin(2 * Pi * 0.5) = 0

cos(2 * Pi * 0.625) = -x
sin(2 * Pi * 0.625) = -x

cos(2 * Pi * 0.75) = 0
sin(2 * Pi * 0.75) = -1

cos(2 * Pi * 0.875) = 1
sin(2 * Pi * 0.875) = 0

xOffset = 0;
yOffset = 0;
cos(2 * Pi * 0) = 1
sin(2 * Pi * 0) = 0
x = 90
y = 50

cos(2 * Pi * 0.125) = 1
sin(2 * Pi * 0.125) = 0.014
x = 
y = 

cos(2 * Pi * 0.25) = 0
sin(2 * Pi * 0.25) = 1
x = 50
y = 90

cos(2 * Pi * 0.375) = -x
sin(2 * Pi * 0.375) = +x

cos(2 * Pi * 0.5) = -1
sin(2 * Pi * 0.5) = 0
x = 10
y = 50

cos(2 * Pi * 0.625) = -x
sin(2 * Pi * 0.625) = -x

cos(2 * Pi * 0.75) = 0
sin(2 * Pi * 0.75) = -1

cos(2 * Pi * 0.875) = +x
sin(2 * Pi * 0.875) = -x

[quote author=Old link=topic=26549.msg190892#msg190892 date=1393158538]
[quote author=8Observer8 link=topic=26549.msg190889#msg190889 date=1393156159]
Скажите, пожалуйста, а реально ли реализовать функцию draw() для моих классов через OpenGL? Это очень сложно?
[/quote]
Реально и не сложно, только эта тема уже будет не ООП. :)
[/quote]

Спасибо! Вы правы. Специфику OpenGL мы здесь обсуждать не будем. Предлагаю взглянуть на рисование фигур с точки зрения ООП (а OpenGL - это просто будет второстепенный инструмент). Объекту какого класса предложить рисование фигур? Мне предлагали сделать функцию draw() полиморфной в Shape, а потом реализацию писать в дочерних классах, потому что "функция знает как себя рисовать" (что-то в этом роде). А я считаю, что нужно завести для рисования специальный класс с методом draw(). В этот метод мы будем передавать константную ссылку на Shape (и ещё смещение по x и y от начала координат, а так же толщину линии) Вот так:

viewer.h
[code=cpp]
class Viewer : public QGLWidget
{
public:
    // ...
    void draw(const Shape &ps, int xOffset, int yOffset, int pointSize = 2);
    // ...
}
[/code]

Но теперь я в тупике. Как объект класса Viewer отличит круг от прямоугольника? А если будет другая фигура? Может передавать в draw массив координат точек вершин? Как Вы полагаете?

Намучился с одной ошибкой. Оказывается свои классы нужно прятать в своё пространство имён. Мой класс Rectangle начал конфликтовать с включением #include <QGLWidget> Пришлось сделать так:

shape.h
[code=cpp]
#ifndef SHAPE_H
#define SHAPE_H

namespace myShapes {

class Shape
{
public:
    // ...
};

}

#endif // SHAPE_H
[/code]

rectangle.h
[code=cpp]
#ifndef RECTANGLE_H
#define RECTANGLE_H

#include "shape.h"

namespace myShapes {

class Rectangle : public Shape
{
public:
    // ...
};

}

#endif // RECTANGLE_H
[/code]

Вот аргументы почему draw() нужно сделать методом класса Viewer, а не методом класса Shape:

Фигура - это объект, который не может совершать действий (к примеру, рисовать сама себя). Да, фигура может расcчитать свою площадь и т.д., но для пользователя это незаметно, ведь он запрашивает площадь так: s = circle.area(). Можно сказать, что фигура обладает определённым набором характеристик (цвет, координаты и т.д.).

В моём случае, объект класса Viewer - это художник. У него есть холст и набор красок. Мы отдаём ему список характеристик фигуры. Художнику не нужно знать, что это за фигура. Он смотрит на список характеристик и находит там координаты точек. Выставляет все точки на холст и соединяет определёнными линиями, закрашивает определённым цветом, располагает фигуры в определённых местах (всю эту информацию содержит сама фигура).

А "компьютерному художнику" приходится хранить у себя эти списки характеристик фигур, чтобы перерисовывать, когда мы, к примеру, меняем размер окна (или перекрываем окно другим окном).

Я ещё не до конца реализовал. С помощью addForPainting(const myShapes::Shape &ps) я буду добавлять фигуру для рисования в закрытый массив std::vector<myShapes::Shape> shapes; и перерисовывать с помощью draw() весь массив фигур из shapes.

viewer.h
[code=cpp]
#ifndef VIEWER_H
#define VIEWER_H

#include <QGLWidget>
#include "shape.h"

#include <vector>

class Viewer : public QGLWidget
{
public:
    // ...
    void addForPainting(const myShapes::Shape &ps);

    // ...
private:
    std::vector<myShapes::Shape> shapes;
    void draw(const myShapes::Shape &ps, int xOffset, int yOffset);
};

#endif // VIEWER_H
[/code]

Вот как пользователь может управлять рисование фигур в main.cpp:

main.cpp
[code=cpp]
[/code]



Я буду потихоньку просматривать предыдущие неразобранные вопросы.

Возвращаюсь к классам геометрических фигур. Скажите, пожалуйста, где лучше хранить координаты фигур? Я остановился на варианте - сделать массив координат вершин в базовом полиморфном классе Shape:

[code=cpp]
class Shape
{
    // ...
	
    void addPoint(int x, int y) {
        m_points.push_back(std::make_pair(x, y));
    }


protected:
    //virtual void calcCoordinates() = 0;
    int m_pointSize;
    std::vector<std::pair<int, int> > m_points;
};
[/code]