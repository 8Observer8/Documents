Ответы на вопросы по C++

С++:
Понимание ООП (наследование, инкапсуляция, полиморфизм), виртуальные функции, статический и динамический полиморфизм, паттерны проектирования, структуры данных (сравнение контейнерных классов STL и Qt), практическая значимость нововведений стандарта с++11, причины утечки памяти и способы борьбы с ними.

Практическая значимость нововведений стандарта с++11:
- добавлена библиотека <chrono>, которая облегчает работу со временем (подробно рассказывается в главе 16)
- добавлена библиотека для работы со случайными числами (подробно рассказывается в главе 16)
- добавлена библиотека <ratio> для работы с рацианальными числами (подробно рассказывается в главе 16)
- добавлена библиотека <tuple>. Позволяет хранить в одном объекте элементы разных типов. Число и тип элеметнов определяется во время компиляции (подробно рассказывается в главе 16)
- добавлена библиотека <regex>. Для работы с регулярными выражениями (поиск по образцу) (подробно рассказывается в главе 14)
- добавлен новый контейнер std::array
- добавлен новый контейнер forward_list. Однонаправленный список
- добавлены новые неупорядоченные ассоциативные контейнеры (хэш таблицы)
- добавлены новые версии push_back() и insert() с move-семантирой (без копирования)

Новые алгоритмы:
Utility Algorithms
- несколько значений для min() и max()
- minmax() - возвращает минимум и максимум как pair объект
Non-Modifying Algorithms
- find_if_not() - возвращает false, если элемент найден
- minmax_element() - возвращает максимальный и минимальный элементы, как pair

Способы борьбы с утечками памяти (для C++11):
- использовать unique_ptr и shared_ptr

Структуры данных:
- vector. Подробно рассказывается в главе 12
   - добавление в конец за константное время O(1)
   - добавление в конец с увеличением размера за время пропорциональное количеству элементов O(n). В среднем выходит O(1)
   - вставка\удаление в\из другое(ого) место(а) пропорцианально количеству элементов O(n)
   - доступ к элементу за константное время O(1) (случайный доступ к элементам)
Вектор нужно использовать там, где неоходим быстрый доступ к элементам и не планируется частые добавления и удаление элементов. Например, нужно использовать vector для хранения списка комьютерных систем, которые занимаются мониторингом. В этом случае удаление и добавление новых компьютерных систем будет нечастым. В тоже время пользователям нужно будет часто получать информацию по отдельному компьютеру.
Примечание. Стандартом не предусмотрена оптимизация для vector<bool>. Лучше использовать bitset

- list. Двунаправленный связанный список. Каждый его элемент содержит ссылки как на следующий, так и на предшествующий элементы.
    - вставка\удаление в\из другое(ого) место (а) за константное время O(1)
    - доступ к элементу за линейное время O(n)

- deque. Double-ended queue - очередь с двусторонним доступом
    - добавление в конец и в начало за константное время O(1)
	- вставка\удаление в\из другое(ого) место(а) пропорцианально количеству элементов O(n)
    - доступ к элементу за константное время O(1)
Нужно использовать там, где нужно добавлять элементы в конец и начало списка. И обеспечить быстрый доступ к элементам

- std::array (C++11). Массив фиксированной длинны

- forward_list (C++11). Singly linked list - однонаправленный список
В отличае от list (двунаправленного связанного списока) продвижение по элементам возможно только в одном направлении. Требует меньше памяти, чем list
    - вставка\удаление в\из другое(ого) место (а) за константное время O(1)
	- доступ к элементу за линейное время O(n)

vector, list, deque, array, и forward_list - это последовательные контейнеры

- queue. First in, First out (FIFO) - Первый пришёл, первый ушёл.
    - вставка в в конец за константное усреднённое время: Усред. O(1)
	- извлечение элемента за константное время: O(1)
	
- priority_queue. Очередь с приоритетами. Вставка и извлечение медленнее, чем у queue

- stack.  First-in, last-out (FILO) - Первым пришёл, последним ушёл
    - вставка\извлечение за константное время: O(1)
Пример: система обработки ошибок. Администратор желает увидеть последние ошибки

queue, priority_queue, и stack - это контейнеры-адапторы. Они предстовляют из себя интерфейс построенный над одним из стандартных последовательных контейнеров: vector, list, deque, array, и forward_list

- set and multiset (для multiset могут быть дубликаты элементов). Set аналогичен математической последовательности с уникальными элементами. Элементы храняться в порядке возрастания (для своих классов нужно написать оператор: operator<)
	- вставка\извлечение\поиск за логарифмическое время (это означает, что вставка\извлечение быстрее, чем у vector'а, но медленее, чем у list. Доступ к элементу (поиск) быстрее, чем у list, но медленне, чем у vector)
	
- map хранит пару: ключ\значение (multimap - для одного ключа может быть несколько значений) 
	- хранит элементы в отсортированном порядке (по ключу)
Примет: ключ - ISBN, значение - объект "Книга" с подробным описанием

set и map называются ассоциативными контейнерами, потому что они ассоциировают ключи с значениями

- bitset. Не является контейнером в обычном смысле. Он имеет фиксированный размер и не поддерживает операторов. Его нужно воспринимать, как последовательность булевых значений, которые можно читать и записывать. Можно создать объект этого типа любым количеством битов: bitset<N>

Неупорядоченные ассоциативные контейнеры - Хэш таблицы
- unordered_map
- unordered_set
- unordered_multimap
- unordered_multiset

вставка\извлечение\поиск за константное усреднённое время: Усред. O(1) (в худшем случае - за линейное время)
доступ к элементам (поиск) может быть более быстрое, чем для map и set

Категории алгоритмов: utility, non-modifying, modifying, sorting, и set

Utility Algorithms
- min(), max() - возвращает минимум и максимум двух значений. С++11 позволяет найти для нескольких значений
- minmax() - возвращает минимум и максимум как pair объект
- swap() меняет местами два значения

Non-Modifying Algorithms Не меняет поняет элементы последовательности и их порядок. Может вызвать фукцию для элементов или возвратить информацию о элементах
- find() - находит элемент и возвращает его позицию (индекс)
- find_if() - возвращает true, если элемент найден
- С++11 find_if_not() - возвращает false, если элемент найден
- find_first_of() - ищет один из нескольких элементов (квадратичное время)
- adjacent_find() - ищет два первых смежных одинаковых элемента
- search() - ищет подпоследовательность в последовательности с начала
- find_end() - ищет подпоследовательность в последовательности с конца
- search_n() - ищет подпоследовательность в последовательности с начала в количестве n элементов
требуют отсортированной последовательности:
- lower_bound() - верхняя граница от заданного числа
- upper_bound() - нижняя граница от заданного числа
- equal_range() - обе границы
- binary_search() - двоичный поиск по отсортированной последовательности (логарифмическая сложность)
- min_element() - возвращает итератор минимального элемента
- max_element() - возвращает итератор максимального элемента
- C++11 all_of() - возвращает true, если последовательность пуста или если предикат возвращает true для всех элементов последовательности
- C++11 any_of() - возвращает false, если последовательность пуста или если предикат возвращает false для всех элементов последовательности
- C++11 non_of() - возвращает true, если последовательность пуста или если предикат возвращает false для всех элементов последовательности
- C++11 partition_point() - возвращает итератор до которого все элементы удовлетворяют предикату, а после итератора - не удовлетворяют
- distance() - указываем начальный итератор и конечный итератор, а получаем количество элементов между ними

Numerical Processing Algorithms
- count() - подсчитывает указанное значение в последовательности
- count_if() - подсчитывает указанное значение в последовательности, которое удовлетворяет условию
- accumulate() - складывает значения с первичной инициализацией. Можно использовать свою фукцию для сложения или объект с переопределённым оператором operator()
- inner_product() - поумолчанию умножает соответствующие элементы и суммирует их
- partial_sum() - частичная сумма. Можно поставить свою операцию вместо суммы. Можно поставить фукнциональный объект std::multiplies<int>()
- adjacent_difference() Реализует операцию:
y0 = x0 
y1 = x1 - x0 
y2 = x2 - x1 
Можно поставить свою операцию вместо суммы. Можно поставить фукнциональный объект std::multiplies<int>()
- equal() - Сравнивает две последовательности (например, vector и обычный массив). Можно использовать свой предикат (функцию для сравнения)
- mismatch - возвращает пару (pair) итераторов, где встречаются первые различные элементы
- lexicographical_compare() - лексиграфическое сравнение двух массивов

Operational Algorithms
- for_each() - для каждого элемента вызывается функция или оператор() из объекта с переопределённым оператором operator()

Modifying Algorithms
- transform() - для каждого элемента последовательности вызывается функция (или функциональный объект), результат сохраняется во второй контейнер. Либо если указан первый, второй и начало первого, а так же функциональный объект, то результат сохраниться во второй
- copy() - копирует элементы, например, из массива в vector
- copy_backward - копирует элементы, начиная с конца (третьим параметром нужно указать конец вектора)
- С++11 iota() - прибавляет к каждому элементу указаное значение
- С++11 copy_if() - копировать только те значения, которые удовлетворяют условию
- С++11 copy_n() - копирует только указанное количество элементов
- С++11 partition_copy() - к примеру, копирует из вектора в другие два вектора, элементы первого удовлетворяют предикату
- С++11 move() - перемещает элементы из одного контейнера в другой
- С++11 move_backward() - перемещает заданный диапазон массива к правому краю, который задать третьим параметром
- iter_swap() - в двух массива меняются элементы по двум итераторам
- swap_ranges() - берёт указанный диапазон из первого и массивы (вектора) меняются элементами
- replace() - заменяет элемент на указанное значение
- replace_if - заменяет элемент на указанное значение, для которого выполняется унарный предикат. Например, замена нечётных чисел нулями
- replace_copy - делает тоже самое, что и replace(), только, к примеру, из исходного массива копирует результат в вектор
- replace_copy - делает тоже самое, что и replace_if(), только, к примеру, из исходного массива копирует результат в вектор
- fill() - указываем с помощью итераторов начало и конец диапазона, и число которым нужно заполнить этот диапазон
- fill_n() - указываем инератор с смещением (или без), число элементов для заполнения, и значение-заполнитель
- generate() - заполняет вектор значением из функции или фукционального объекта
- generate_n() - указываем начало массива, количество элементов и фукнцию для генерирования элементов
- remove() - указываем начало массива (через указатель), конец массива (указатель на начало плюс смещение) и значение, которое нужно удалить
- remove_if() - указываем начало массива (через указатель), конец массива (указатель на начало плюс смещение) и унарный предикат, который принимает элемент и проверяет заданое условие
- remove_copy() - указываем начало массива (через указатель), конец массива (указатель на начало плюс смещение), вектор (куда будет скопирован результат), элемент для сравнения (который нужно удалить)
- remove_copy_if() - указываем начало массива (через указатель), конец массива (указатель на начало плюс смещение), вектор (куда будет скопирован результат) и унарный предикат, который принимает элемент и проверяет заданое условие
- unique() - указываем итератор начала контейнера и итератор конца. Из исходного контейнера удаляются последовательные дубликаты. Мы можем указать начальный и конечный итераторы, а так же бинарный предикат возвращающий bool
- unique_copy() - указываем начало массива, конец массива, вектор куда буду скопирваны результаты
- reverse() - задаём начальный и конечный итератор. Фукция переворачивает порядок элементов
- reverse_copy() - указываем начало и конец массива, вектор (предворительно выделяем место .resize())? Функция копирует результат переворачивания в вектор
- rotate() - указываем итератор начала отрезка, итератор конца отрезка и итератор конца вектора. Функция меняет отрезки местами
- rotate_copy() - делает тоже самое, что и функция выше, но в отдельный массив
- next_permutation() - задаём начало и конец массива. Фукнция после вызова меняет порядок элементов, выдовая новую комбинацию, когда комбинации заканчиваются, возращает false
- prev_permutation() - делает тоже самое, что и предыдущая, только даёт комбинации в другом порядке

Sorting Algorithms
- sort() - указываем начальный итератор, итератор плюс смещение. Функция сортирует элементы. Мы может третьим параметом указать функция для сравнения или свой функциональный объект
- stable_sort() - сортирует так же как и sort(), но возможна сортировка по целому, когда целые не сортируются и игнорируются дробные части
- partial_sort() - указываем начальный итератор контейнера, начальный итератор отрезка и конечный итератор отрезка. Функция сортирует между начальным итератором отрезка и конечным итератором отрезка
- partial_sort_copy() - делает тоже самое, что и предыдущая, только "не портит" исходный контейнер (массив), а результат копирует в третий контейнер
- nth_element() - указываем начальный итератор контейнера, начальный итератор отрезка и конечный итератор отрезка. Функция сортирует между начальным итератором отрезка и конечным итератором отрезка
- merge() - нужно предварительно отсортировать два массива. Указываем начало массива, конец массива, начало второго массива, конец второго массива, контейнер (вектор для выхода). Фукнция смешивает и сортирует оба массива, а результат помещает в контейнер
- inplace_merge() - делает тоже самое, что и предыдущая функция, но сливает вместе две отсортированные половинки
- make_heap() - реорганизуте контейнер для использования фукнций: push_heap, pop_heap, sort_heap. Максимальный можно получить с помощью front(). Добавить можно с помощью push_back() (потом нужно вызвать push_heap()). Извлечь с помощью pop_back() (перед этим нужно вызвать pop_heap). Можно сортировать sort_heap()
- C++11 is_heap() - проверяет была ли применена операция make_heap к контейнеру
- C++11 is_heap_until() - пытается найти в контейнере последовательность, которая было создана с помощью make_heap()
- push_heap() - реорганизует контейнер для операции push_back()
- pop_heap() - реорганизует контейнер для операции push_back()
- sort_heap() - реорганизует контейнер для операции push_back()
- partition() - разделяет элементы до итератора и после по заданому условия (унарного предиката) для каждого элемента. Порядок элементов не сохраняется
- stable_partition() - делает тоже самое, что и предыдущая, но порядок следования сохряняется
- random_shuffle() - перемешивает элементы в контейнере. Можно использовать унарную функцию, или функциональный объект
- С++11 is_sorted() - проверяет отсортирован ли массив или нет
- С++11 is_sorted_until() -  поиск отсортированной последовательности

Set Algorithms
- includes() - принимает два отсортированных массива (их начала и концы). Возвращает true, если первый массив включает в себя элементы второго
- set_union() - принимает два отсортированных массива (их начала и концы), а так же начало контейнера. Заполняет контейнер элементами по одному из каждого массива. Возвращает итератор конца контейнера
- set_intersection() - принимает два отсортированных массива (их начала и концы), а так же начало контейнера. Заполняет контейнер элементами, которые являются общими для двух массивов. Возвращает итератор конца контейнера
- set_difference() - принимает два отсортированных массива (их начала и концы), а так же начало контейнера. Заполняет контейнер элементами, которые являются разными относительно первого. Возвращает итератор конца контейнера
- set_symmetric_difference() - принимает два отсортированных массива (их начала и концы), а так же начало контейнера. Заполняет контейнер элементами, которые являются разными для двух массивов. Возвращает итератор конца контейнера



С STL-контейнерами (если мы храним указатели) нужно использовать shared_ptr (C++11). Либо SuperSmartPointer класс из главы 21
Примечание: нельзя использовать auto_ptr из-за плохой реализации копирования


Приимущества итераторов, перед индексами:
- Iterators allow you to insert and delete elements and sequences of elements at any point in 
the container. See the following “Adding and Removing Elements” section.
- Iterators allow you to use the STL algorithms, which are discussed in Chapter 13.
- Using an iterator to access each element sequentially is often more ef?  cient than indexing 
the container to retrieve each element individually. This generalization is not true for 
vectors, but applies to lists, maps, and sets.


> практическая значимость нововведений стандарта с++11
Важнные нововведения, которые касаются STL:
- введены новые контейнеры: хэш-контейнеры
- move-кострукторы и move-операторы присваивания (r-значения описаны в главе 9) С их помощью можно вернуть контейнер из функции по значению, без уменьшения производительности
Так же можно использовать эту семантику для вставки элемента без копирования vec.push_back(Element(12, “Twelve”));
vec.push_back({12, “Twelve”}); То есть создаётся временный объект, который перемещается в vector без копирования
- введена для некоторых контейнеров "вставка на месте" vec.emplace_back(12, “Twelve”); ничего не копируется и не перемещается (реализованно, как Variadic-шаблон, обсуждается в главе 20)


Подробно о C++11 написано в главе 9 (реализована семантика move)


