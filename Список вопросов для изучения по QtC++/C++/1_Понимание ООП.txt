Понимание ООП. Проект, который охватывает принципы ООП

Понимание ООП (наследование, инкапсуляция, полиморфизм), виртуальные функции, статический и динамический полиморфизм

Виртуальные функции нужны для настройки производных классов. Если класс содержит виртуальные фукнции, то необходимо объявлять витруальный диструктов в базовом, затем чтобы удалить объект производного класса через указатель на объект базового класса.

Цитата из Правила 7:
Если же класс не имеет виртуальных функций, это часто означает, что он не предназначен быть базовым. А в таком классе определять виртуальный деструктор не стоит.






Если в классе создаётся хотя бы одна виртуальная функция, то весь класс становится чисто виртуальным.

Мы не можем создать объект чисто виртуального класса. Он служит интерфейсом, который мы можем наследовать и обязаны написать реализацию для чисто виртуальных функции, так как они её не имеют.

Пример:
[code=cpp]
[/code]

Просто виртуальные функции-члены имеют реализацию по умолчанию. Мы их можем переопределить.

Обычные функции-члены мы не можем переопределить.



Всем большое спасибо! Начну с простого.

Поступим следующим образом: я буду писать классы, а вы их критикуйте. Задача у меня - довести каждый класс до уровня профи. Классы будут демонстрировать один или несколько принципов ООП. Подкидывайте, пожалуйста, идеи - какие принципы и на каких классах ещё можно рассмотреть.

Примеры будут на Qt и на C++, чтобы меня не ругали, что это форум Qt, а не C++.

[b]Рациональные числа[/b]

Примечания. Пример взял отсюда: http://www.e-reading.co.uk/chapter.php/1002058/56/Mayers_-_Effektivnoe_ispolzovanie_CPP.html

В примере затронуты следующие темы:

- список инициализации в конструкторе
- дружественные функции
- перезагрузка операторов: умножения, сложения и вычитания.

Какие ещё операторы посоветуете перезагрузить? Как дальше доработать этот класс?

Примечание. При сложении и вычитании дробей: к общему знаменателю привожу - перемножением, результат не сокращаю.

Вывод:
product = 6/24
sum = 1472/768
sub = 32/768

main.cpp
[code=cpp]
[/code]

rational.h
[code=cpp]
[/code]

rational.cpp
[code=cpp]
[/code]

                                                     ^

Примечание. Пример "Комплексные числа" я взял из книги "Изучаем C++" и доработал его (там ещё есть несколько интересных примеров). Правда книга рассчитана на "школьников средних и старших классов", как об этом написано на ozon.ru в описании: http://www.ozon.ru/context/detail/id/1431795/

Может кому-то случайно пригодится (очень хорошая книжка) http://rutracker.org/forum/viewtopic.php?t=3658199
Я в интернете находил исходники к ней.

[b]Комплексные числа[/b]

В примере затронуты следующие темы:

- список инициализации закрытых переменных в конструкторе
- перезагрузка операторов сравнения и вывода в консоль

[code=cpp]
[/code]


Igors, Спасибо! я помню про тот пример. Вернусь к нему позже. Спасибо за новый!

[quote author=m_ax link=topic=26549.msg190627#msg190627 date=1392728332]
[quote]
Примечание. При сложении и вычитании дробей: к общему знаменателю привожу - перемножением, результат не сокращаю.
[/quote]

Это плохо( 
Во-вторых, хотелось бы иметь операторы сравнения..
И такие, чтобы, например, 4/2 и 10/5 получались  равными друг другу) 

И ещё я бы посмотрел на Compile-time rational arithmetic [url=http://en.cppreference.com/w/cpp/numeric/ratio]http://en.cppreference.com/w/cpp/numeric/ratio[/url]
[/quote]

Да, Вы правы! Но мне не хочется замарачиваться с сокращениями дробей и поиском наименьшего общего знаменателя. Время дорого. Тут главное ООП освоить.

После прочтения вот этого правила, у меня возникли сложности с пониманием: [b]Правило 23: Предпочитайте функциям-членам функции, не являющиеся ни членами, ни друзьями класса[/b] http://www.e-reading.co.uk/chapter.php/1002058/60/Mayers_-_Effektivnoe_ispolzovanie_CPP.html

Получается, что оператор вывода на экран (<<) НЕ должен быть частью класса Relation, так как это не свойство чисел (вывод на экран не относится к классу Relation, так как с точки зрения математики у рациональных чисел есть только свойства сложения, сравнения и т.д.). Следуя правилу, оператор вывода нужно располагать отдельно от класса Relation и даже не friend, а отдельной функцией. Но в том же пространстве имён. А можно ли так делать? C++ позволяет ли создавать свободные операторные функции? Под свободными функциями имеются ввиду функции, которые не являются ни членами-функциями класса, ни функциями-друзьями.


Правильно ли я это понял? Вот пример:




Скажите, пожалуйста, правильно ли я понял, что единственное для чего нужен полиморфизм - это чтобы писать функции, которые принимают указатель на базовый класс и работают с объектами производных классов (так сказать - для уменьшения дублирования кода)

Вот пример:

main.cpp
[code=cpp]
[/code]

shape.h
[code=cpp]
[/code]

shape.cpp
[code=cpp]
[/code]

circle.h
[code=cpp]
[/code]

circle.cpp
[code=cpp]
[/code]

cube.h
[code=cpp]
[/code]

cube.cpp
[code=cpp]
[/code]

P.S. Сделал в Shape переменные закрытыми согласно этому правилу: "Правило 22: Объявляйте данные-члены закрытыми" http://www.e-reading.co.uk/chapter.php/1002058/58/Mayers_-_Effektivnoe_ispolzovanie_CPP.html так как в данном случае мы используем переменные [b]только для чтения[/b]

P.S.S В Shape сделал деструктор виртуальным, потому что в противном случае мы не можем уничтожить объект производного класса через указатель на базовый (так как не вызывается деструктор производного класса). Написано в правиле: "Правило 7: Объявляйте деструкторы виртуальными в полиморфном базовом классе" http://www.e-reading.co.uk/chapter.php/1002058/26/Mayers_-_Effektivnoe_ispolzovanie_CPP.html


[quote author=Johnik link=topic=26549.msg190758#msg190758 date=1392927407]
Параметры объекта передавать в конструкторе.
[/quote]

Спасибо за ответ! Но идея, которую я хучу реализовать заключается в том, чтобы от астрактного класса унаследовать интерфейс:

[code=cpp]
#ifndef SHAPE_H
#define SHAPE_H

class Shape
{
    // ...
    virtual void calcPerimeter() = 0;
    virtual void calcArea() = 0;
	// ...
};
[/code]

А пользователю предоставить возможность создавать свои классы (унаследованные от моего) с требуемым ему набором параметром для calcPerimeter() и calcArea()

circle.h
[code=cpp]
#ifndef CIRCLE_H
#define CIRCLE_H

#include "shape.h"

class Circle : public Shape
{
public:
    Circle();
    double calcPerimeter(double radius);
    double calcArea(double radius);
};

#endif // CIRCLE_H
[/code]

rectangle.h
[code=cpp]
#ifndef RECTANGLE_H
#define RECTANGLE_H

#include "shape.h"

class Rectangle : public Shape
{
public:
    Rectangle();
    double calcPerimeter(double a, double b);
    double calcArea(double a, double b);
};

#endif // RECTANGLE_H
[/code]


Я так понимаю, что чисто виртуальные фунции нужно использовать лишь тогда, когда знаешь точное количество аргументов функции.



[quote author=Johnik link=topic=26549.msg190767#msg190767 date=1392967038]
что мешает сделать так:
[code=cpp]
#ifndef CIRCLE_H
#define CIRCLE_H
 
#include "shape.h"
 
class Circle : public Shape
{
public:
    Circle(double radius);
    double calcPerimeter();
    double calcArea();
};
 
#endif // CIRCLE_H
[/code]
[code=cpp]
#ifndef RECTANGLE_H
#define RECTANGLE_H
 
#include "shape.h"
 
class Rectangle : public Shape
{
public:
    Rectangle(double a, double b);
    double calcPerimeter();
    double calcArea();
};
 
#endif // RECTANGLE_H
[/code]
[/quote]

У Вас неверный подход, так как Вы свели пользу от абстрактного класса к минимуму. В Вашем случае 

Немного усовершенствовал Вашу идею. Создал иерархию классов, которая позволяет следующее:

- мы можем создать объект с заранее установленными параметрами (в конструкторе с параметрами). Пользователь (разработчик производных классов от Shape) сам решает какие параметры будет принимать конструктор.

Из конструктора будут вызваны функции для расчёта периметра и площади (эти функции чисто витруальные в классе Shape)

- пользователь класса Shape может создать объект с нулевыми параметрами (конструктор без параметров)
- мы можем установить параметры для объекта (в этом случае, будут вызваны функции для рассчёта периметра и площади)
- функции для рассчёта периметра и площади расположены в private секции

Таким образом мы можем только создавать объекты с параметрами и менять параметры. При смене таких параметров, как, к примеру радиус, будут меняться периметр и площадь. Которые мы можем узнать.



[quote author=Igors link=topic=26549.msg190850#msg190850 date=1393057241]
[code=cpp]
class Circle
{
public:
    inline double perimeter(double radius) const {
        return (2.0 * M_PI * radius);[/code]
Такое вычисление имеет смысл, но оно никак не зависит от самого класса, его членов. Значит это static метод. Но так Вам надо иметь радиус "на стороне". Хорошо увязать это вместе, напр
[code=cpp]
class Circle : public Shape
{
public:
...
    static double perimeter(double radius) 
   {
        return (2.0 * M_PI * radius);
   }

   virtual double perimeter( void ) const
   {
      return perimeter(radius);
   }
  
private:  
  double m_radius;   
[/code]
[/quote]

Посмотрите, пожалуйста, правильно ли я реализовал Вашу идею:
